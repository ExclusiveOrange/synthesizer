'this is a single-line comment
"this type of comment can go anywhere"

"operation counts:
	sine x 10
	add x 9
	mul x 2
	total: 21 operations"

halfstep = 2^(1/12);
step = halfstep * halfstep;

'here we define some variables to use as specific notes later
a1 = 27.5;
b1 = a1 * step;
c1 = b1 * halfstep;
cf1 = c1 * halfstep;
d1 = c1 * step;
e1 = d1 * step;
f1 = e1 * halfstep;
g1 = f1 * step;
gf1 = g1 * halfstep;

'going to use this for the duration of this instance
	d = 5;
'going to use this for the maximum magnitude of any one component
	m = 3;

'minimum octave
	minpow = 2;
'maximum octave (we want a fair shot at 5 and we'll be rounding down later)
	maxpow = 5.999999;
'modulo divisor of our note for rounding
	divisor = 1;

'magnitude of sinusoid distortion
	warblemag = halfstep^(1/12);
'frequency of sinusoid distortion
	warblefreq = 1/512;

'sets the time range to [0, d] seconds
	0,d;

'temporary variable for this particular key
	key = c1;
'pick a random power between minpow and maxpow
	power = minpow # maxpow;
'round down to the next multiple of divisor
	power -= power % divisor;
'now we raise our key to the octave selected by power
	rand = key*2^power;
'higher frequencies ought to be quieter
	mag = m/(rand^.4);
'this generates the distortion sinusoid to register r3
	sine r3, rand*warblemag-rand, rand*warblefreq, 0;
'we need to center the distortion sinusoid around our note
	add r3, r3, rand;
'this generates the note sinusoid to register r2, using the frequencies in register r3
	sine r2, mag*(0#1), r3, 0;

'below is more of the same for more keys

key = d1;
power = minpow # maxpow;
power -= power % divisor;
rand = key*2^power;
mag = m/(rand^.4);
sine r3, rand*warblemag-rand, rand*warblefreq, 0;
add r3, r3, rand;
sine r3, mag*(0#1), r3, 0;
add r2, r2, r3;

key = e1;
power = minpow # maxpow;
power -= power % divisor;
rand = key*2^power;
mag = m/(rand^.4);
sine r3, rand*warblemag-rand, rand*warblefreq, 0;
add r3, r3, rand;
sine r3, mag*(0#1), r3, 0;
add r2, r2, r3;

key = g1;
power = minpow # maxpow;
power -= power % divisor;
rand = key*2^power;
mag = m/(rand^.4);
sine r3, rand*warblemag-rand, rand*warblefreq, 0;
add r3, r3, rand;
sine r3, mag*(0#1), r3, 0;
add r2, r2, r3;

key = a1;
power = minpow # maxpow;
power -= power % divisor;
rand = key*2^power;
mag = m/(rand^.4);
sine r3, rand*warblemag-rand, rand*warblefreq, 0;
add r3, r3, rand;
sine r3, mag*(0#1), r3, 0;
add r2, r2, r3;

'ADSR: Attack, Decay, Sustain, Release - it shapes the amplitude of our mix
0,1/128; 'sets the time range to [0, 1/128] seconds
line r1, 0, 1; 'draws a line in r1 from 0 to 1 - effectively ramping up the volume from 0 to 1
'+1/128; 'sets the time range to [1/128, 2/128]
'fill r1, 1; 'effectively sets the volume to 1 for this time range
,d; 'sets the time range to [2/128, d]
line r1, 0, -5;
exp r1, r1; 'exponential function, using the line from 0 to -5 as input - effectively creates a nice exponential decay
d-(1/128),d; 'sets the time range to [d - 1/128, d];
line r3, 1, 0; 'the exponential decay doesn't end with 0, so we need to ramp it down to 0
mul r1, r1, r3; 'this applies our ramp down to the ADSR

0,d; 'sets the time range to [0, d]
mul r0, r1, r2; 'muliplies our ADSR by our sinusoid mix, and stores the result in the output register, r0

'notes:
'the only reserved words are the instruction names and register names.
'for instruction names, see "source instructions.txt"
'there are 8 registers available, r0-r7; you can use them however you want, but output is only read from r0 at the end

'time coding:
'there are three ways to change the time range:
'	start, end;
'		this clearly defines the start and end time
'	, end;
'		this uses the end of the previously defined range as the start of this range, and sets the new end to 'end'
'	+ increment;
'		this uses the end of the previously defined range as the start of this range, and adds 'increment' to the end
'the time range used by any instruction (sine, triangle, exp, etc.) is always the most recently defined time range as
'read from top to bottom of this file.

